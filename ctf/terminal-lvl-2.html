<!DOCTYPE html>
<html lang="en">
<head> 
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self' https://hackerfrankone.github.io; 
    script-src 'self' 'unsafe-inline'; 
    style-src 'self' 'unsafe-inline'; 
    img-src 'self' https://www.paypalobjects.com; 
    frame-src 'self' https://hackerfrankone.github.io;
    object-src 'self' https://hackerfrankone.github.io;
    connect-src 'self' https://student-live.oppcus2025.workers.dev;" />
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()" />
  <title>Oppcus CTF Terminal - Level 2</title>
  <link rel="icon" type="image/png" href="images/oppcus.png" />
  <style>
    body {
      background: black;
      color: #33ff33;
      font-family: monospace;
      margin: 0;
      padding: 0;
    }
    #terminal {
      padding: 10px;
      white-space: pre-wrap;
      outline: none;
    }
    .input-line {
      display: inline;
    }
    .cursor {
      display: inline;
      background: #33ff33;
      color: black;
      animation: blink 1s step-start infinite;
    }
    @keyframes blink {
      50% { background: black; color: #33ff33; }
    }
  </style>
</head>
<body>
  <div id="terminal" tabindex="0"></div>

  <script>
    const terminal = document.getElementById("terminal");

    let fileSystem = {
      "/home": ["student"],
      "/home/student": ["Desktop", "Documents", "Downloads"],
      "/home/student/Desktop": [".hidden.txt", "notes.txt", "more-notes.txt", ".malicious-contents.txt"],
      "/home/student/Documents": [],
      "/home/student/Downloads": []
    };

    let fileContents = {
      "/home/student/Desktop/.hidden.txt": "ctf_0001",
      "/home/student/Desktop/notes.txt":
        "Some things hide in plain sight...\n" +
        "Not all treasures shout their name.\n\n" +
        "Look closely, but remember:\n" +
        "- A casual glance (`ls`) wonâ€™t show you everything.\n" +
        "- Sometimes you must *ask for all* to see the unseen.\n" +
        "Once revealed, only then can you read the truth.",
      "/home/student/Desktop/more-notes.txt": "If access is denied. Must be permissions.",
      "/home/student/Desktop/.malicious-contents.txt": "ctf_0002"
    };

    let permissions = {
      "/home/student/Desktop/.malicious-contents.txt": {
        owner: { read: false, write: true, execute: true },
        group: { read: false, write: false, execute: false },
        others: { read: false, write: false, execute: false }
      }
    };

    let cwd = "/home/student";
    let history = [];
    let currentInput = "";
    let cursorPos = 0;

    const commandsList = ["ls", "ls -a", "ls -l", "cd", "cat", "pwd", "clear", "exit", "file", "chmod"];

    function renderPrompt() {
      return `student@oppcus:${cwd.replace("/home/student", "~")}$ `;
    }

    function renderTerminal() {
      terminal.innerHTML = "";
      history.forEach(line => terminal.innerHTML += line + "\n");
      let before = currentInput.slice(0, cursorPos);
      let atCursor = currentInput[cursorPos] || " ";
      let after = currentInput.slice(cursorPos + 1);
      terminal.innerHTML += `<span class="input-line">${renderPrompt()}${before}<span class="cursor">${atCursor}</span>${after}</span>`;
      terminal.scrollTop = terminal.scrollHeight;
    }

    function resolvePath(path) {
      if (!path) return cwd;
      let resolved = path.startsWith("/") ? path : (cwd === "/" ? "" : cwd) + "/" + path;
      resolved = resolved.replace(/\/+/g, "/").replace(/\/$/, "");
      if (resolved === "") resolved = "/";
      return resolved;
    }

    function getPermissionsString(filePath) {
      const perms = permissions[filePath];
      if (!perms) return "rwxr-xr-x"; // Default for other files
      const owner = perms.owner;
      const group = perms.group;
      const others = perms.others;
      return `${owner.read ? "r" : "-"}${owner.write ? "w" : "-"}${owner.execute ? "x" : "-"}` +
             `${group.read ? "r" : "-"}${group.write ? "w" : "-"}${group.execute ? "x" : "-"}` +
             `${others.read ? "r" : "-"}${others.write ? "w" : "-"}${others.execute ? "x" : "-"}`;
    }

    function runCommand(input) {
      let args = input.trim().split(" ").filter(Boolean);
      let cmd = args[0];
      let output = "";

      if (!cmd) return "";

      let file; // Declare file variable once for the entire function

      switch(cmd) {
        case "ls":
          let showHidden = args.includes("-a");
          let showLong = args.includes("-l");
          let pathArg = args.find(a => !a.startsWith("-")) || null;
          if ((args[1] === "-a" || args[1] === "-l" || args[1] === "-la" || args[1] === "-al") && args[2]) pathArg = args[2];

          let pathToList = resolvePath(pathArg);
          if (!fileSystem[pathToList]) {
            output = `ls: cannot access '${pathArg || pathToList}': No such file or directory`;
            break;
          }
          let files = fileSystem[pathToList] || [];
          if (showLong) {
            let outputLines = [];
            files.forEach(file => {
              let filePath = pathToList + "/" + file;
              let permString = fileContents[filePath] ? getPermissionsString(filePath) : "drwxr-xr-x";
              outputLines.push(`${permString} ${file}`);
            });
            if (showHidden) {
              outputLines.unshift("drwxr-xr-x .");
              outputLines.unshift("drwxr-xr-x ..");
            }
            output = outputLines.join("\n");
          } else {
            if (showHidden) {
              output = [".", "..", ...files].join("  ");
            } else {
              output = files.filter(f => !f.startsWith(".")).join("  ");
            }
          }
          break;

        case "cd":
          let target = args[1] || "/home/student";
          if (target === "..") {
            if (cwd !== "/home/student") cwd = cwd.split("/").slice(0, -1).join("/") || "/";
          } else if (target === "~") cwd = "/home/student";
          else {
            let newPath = resolvePath(target);
            if (fileSystem[newPath]) cwd = newPath;
            else output = `bash: cd: ${target}: No such file or directory`;
          }
          break;

        case "cat":
          file = args[1];
          if (!file) {
            output = "bash: cat: missing operand";
          } else {
            let filePath = resolvePath(file);
            if (fileContents[filePath]) {
              if (permissions[filePath] && !permissions[filePath].owner.read) {
                output = `bash: cat: ${file}: Permission denied`;
              } else {
                output = fileContents[filePath];
              }
            } else {
              output = `bash: cat: ${file}: No such file or directory`;
            }
          }
          break;

        case "pwd":
          output = cwd;
          break;

        case "clear":
          history = ["Type 'exit' to return to Home"];
          currentInput = "";
          cursorPos = 0;
          return "";

        case "exit":
          window.location.href = "select.html";
          break;

        case "file":
          let targetFile = args[1];
          if (!targetFile) {
            output = "file: missing operand";
          } else if (targetFile === "." || targetFile === "..") {
            output = `${targetFile}: directory`;
          } else {
            let filePath = resolvePath(targetFile);
            if (fileSystem[filePath]) {
              output = `${targetFile}: directory`;
            } else if (fileContents[filePath]) {
              output = `${targetFile}: ASCII text`;
            } else {
              output = `file: cannot access '${targetFile}': No such file or directory`;
            }
          }
          break;

        case "chmod":
          let mode = args[1];
          file = args[2];
          if (!mode || !file) {
            output = "chmod: missing operand";
          } else {
            let filePath = resolvePath(file);
            if (!fileContents[filePath]) {
              output = `chmod: cannot access '${file}': No such file or directory`;
            } else {
              if (mode === "u+r") {
                if (!permissions[filePath]) {
                  permissions[filePath] = { owner: { read: false, write: false, execute: false }, group: {}, others: {} };
                }
                permissions[filePath].owner.read = true;
                output = "";
              } else {
                output = `chmod: only 'u+r' is supported for this challenge`;
              }
            }
          }
          break;

        default:
          output = `bash: ${cmd}: command not found`;
      }

      return output;
    }

    function autocomplete() {
      let args = currentInput.trim().split(" ");
      let last = args[args.length - 1];
      let matches = [];

      if (!args[0]) {
        matches = commandsList.filter(c => c.startsWith(last));
      } else if (["ls", "ls -a", "ls -l", "cd", "cat", "file", "chmod"].includes(args[0]) || (args[0] === "ls" && (args[1] === "-a" || args[1] === "-l"))) {
        let pathParts = last.split("/");
        let dir = cwd;
        let prefix = "";
        
        if (last.includes("/")) {
          let parentPath = pathParts.slice(0, -1).join("/");
          let resolvedParent = resolvePath(parentPath);
          if (fileSystem[resolvedParent]) {
            dir = resolvedParent;
            prefix = parentPath + "/";
          } else {
            return;
          }
          last = pathParts[pathParts.length - 1];
        }

        let items = fileSystem[dir] || [];
        matches = items.filter(f => f.startsWith(last)).map(f => prefix + f);
        if ([".", ".."].includes(last)) matches.push(prefix + last);
      } else {
        matches = commandsList.filter(c => c.startsWith(last));
      }

      if (matches.length === 1) {
        args[args.length - 1] = matches[0];
        currentInput = args.join(" ");
        cursorPos = currentInput.length;
      }
    }

    document.addEventListener("keydown", (e) => {
      if (e.key === "Backspace") {
        currentInput = currentInput.slice(0, cursorPos - 1) + currentInput.slice(cursorPos);
        cursorPos = Math.max(0, cursorPos - 1);
        e.preventDefault();
      } else if (e.key === "Enter") {
        let command = currentInput;
        history.push(renderPrompt() + command);
        let result = runCommand(command);
        if (result) history.push(result);
        currentInput = "";
        cursorPos = 0;
      } else if (e.key === "ArrowLeft") cursorPos = Math.max(0, cursorPos - 1);
      else if (e.key === "ArrowRight") cursorPos = Math.min(currentInput.length, cursorPos + 1);
      else if (e.key === "Tab") {
        autocomplete();
        e.preventDefault();
      } else if (e.key.length === 1) {
        currentInput = currentInput.slice(0, cursorPos) + e.key + currentInput.slice(cursorPos);
        cursorPos++;
      }
      renderTerminal();
    });

    // startup message
    history.push("Type 'exit' to return to Home");
    renderTerminal();
  </script>
</body>
</html>
