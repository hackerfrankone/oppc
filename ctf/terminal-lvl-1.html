<!DOCTYPE html>
<html lang="en">
<head> 
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self' https://hackerfrankone.github.io; 
    script-src 'self' 'unsafe-inline'; 
    style-src 'self' 'unsafe-inline'; 
    img-src 'self' https://www.paypalobjects.com; 
    frame-src 'self' https://hackerfrankone.github.io;
    object-src 'self' https://hackerfrankone.github.io;
    connect-src 'self' https://student-live.oppcus2025.workers.dev;" />
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()" />
  <title>Oppcus CTF Terminal</title>
  <link rel="icon" type="image/png" href="images/oppcus.png" />
  <style>
    body {
      background: black;
      color: #33ff33;
      font-family: monospace;
      margin: 0;
      padding: 0;
      position: relative;
    }
    #terminal {
      padding: 10px;
      white-space: pre-wrap;
      outline: none;
    }
    .input-line {
      display: inline;
    }
    .cursor {
      display: inline;
      background: #33ff33;
      color: black;
      animation: blink 1s step-start infinite;
    }
    @keyframes blink {
      50% { background: black; color: #33ff33; }
    }
    #popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      color: #33ff33;
      padding: 20px;
      border: 2px solid #33ff33;
      z-index: 1000;
      text-align: center;
      max-width: 400px;
      font-size: 16px;
    }
    #popup button {
      background: black;
      color: #33ff33;
      border: 1px solid #33ff33;
      font-family: monospace;
      font-size: 14px;
      padding: 5px 10px;
      margin-top: 10px;
      cursor: pointer;
    }
    #popup button:hover {
      background: #33ff33;
      color: black;
    }
  </style>
</head>
<body>
  <div id="popup">You've hacked into a criminal's computer who is a terrorist and is planning an attack. Locate and download the malicious-contents and report it to the authorities</div>
  <div id="terminal" tabindex="0"></div>

  <script>
    const terminal = document.getElementById("terminal");
    const popup = document.getElementById("popup");

    let fileSystem = {
      "/home": ["student"],
      "/home/student": ["Desktop", "Documents", "Downloads"],
      "/home/student/Desktop": [".malicious-contents.txt"],
      "/home/student/Documents": [],
      "/home/student/Downloads": []
    };

    let fileContents = {
      "/home/student/Desktop/.malicious-contents.txt": "ctf_1010101010010101"
    };

    let filePermissions = {
      "/home/student/Desktop/.malicious-contents.txt": { r: false, w: true, x: true }
    };

    let cwd = "/home/student";
    let history = [];
    let currentInput = "";
    let cursorPos = 0;

    const commandsList = ["ls", "ls -a", "ls -l", "cd", "cat", "pwd", "clear", "exit", "file", "chmod", "man", "scp", "cp"];

    const manPages = {
      "ls": `LS(1)                    User Commands                   LS(1)

NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [DIR]...

DESCRIPTION
       List information about the contents of DIR (the current directory by default).

OPTIONS
       -a, --all
              do not ignore entries starting with .
       -l
              use a long listing format, showing permissions, size, and date.

EXAMPLES
       ls
              List non-hidden files in the current directory.
       ls -a
              List all files, including hidden ones starting with '.'.
       ls -l
              List files with permissions (e.g., -rwxr-xr-x), size, date, and name.
       ls Desktop
              List non-hidden files in the Desktop directory.
       ls -l Desktop
              List files in Desktop with permissions, size, date, and name.

SEE ALSO
       man(1)`,
      "cd": `CD(1)                    User Commands                   CD(1)

NAME
       cd - change the shell working directory

SYNOPSIS
       cd [DIRECTORY]

DESCRIPTION
       Change the current directory to DIRECTORY. The default is the user's home directory.

       ..     Move to the parent directory.
       ~      Move to the home directory.

EXAMPLES
       cd Desktop
              Change to the Desktop directory.
       cd ..
              Move up one directory level.

SEE ALSO
       pwd(1), man(1)`,
      "cat": `CAT(1)                   User Commands                   CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [FILE]...

DESCRIPTION
       Concatenate FILE(s) to standard output.

EXAMPLES
       cat file.txt
              Display the contents of file.txt.

SEE ALSO
       man(1)`,
      "pwd": `PWD(1)                   User Commands                   PWD(1)

NAME
       pwd - print name of current/working directory

SYNOPSIS
       pwd

DESCRIPTION
       Print the full pathname of the current working directory.

EXAMPLES
       pwd
              Output the current directory, e.g., /home/student

SEE ALSO
       cd(1), man(1)`,
      "clear": `CLEAR(1)                 User Commands                   CLEAR(1)

NAME
       clear - clear the terminal screen

SYNOPSIS
       clear

DESCRIPTION
       Clear the terminal screen, removing all previous output.

SEE ALSO
       man(1)`,
      "exit": `EXIT(1)                  User Commands                   EXIT(1)

NAME
       exit - exit the shell

SYNOPSIS
       exit

DESCRIPTION
       Exit the terminal, returning to the home interface.

SEE ALSO
       man(1)`,
      "file": `FILE(1)                  User Commands                   FILE(1)

NAME
       file - determine file type

SYNOPSIS
       file [FILE]...

DESCRIPTION
       Determine the type of FILE(s).

EXAMPLES
       file file.txt
              Identify file.txt as ASCII text or other type.

SEE ALSO
       man(1)`,
      "chmod": `CHMOD(1)                 User Commands                   CHMOD(1)

NAME
       chmod - change file mode bits

SYNOPSIS
       chmod MODE FILE...

DESCRIPTION
       Change the permissions of FILE(s) according to MODE.

       MODE can be:
       +r     Add read permission.
       +4     Add read permission (numeric mode).

EXAMPLES
       chmod +r file.txt
              Grant read permission to file.txt.

SEE ALSO
       man(1)`,
      "scp": `SCP(1)                   User Commands                   SCP(1)

NAME
       scp - secure copy (remote file copy program)

SYNOPSIS
       scp [FILE]

DESCRIPTION
       Copy FILE to the local system securely. Requires read permissions on the file.

EXAMPLES
       scp file.txt
              Copy file.txt to the local system.

SEE ALSO
       cat(1), chmod(1), cp(1), man(1)`,
      "cp": `CP(1)                    User Commands                   CP(1)

NAME
       cp - copy files and directories

SYNOPSIS
       cp SOURCE DEST

DESCRIPTION
       Copy the SOURCE file to the DEST location within the file system. Requires read permissions on the source file.

EXAMPLES
       cp file.txt ../Downloads/
              Copy file.txt to the Downloads directory.

SEE ALSO
       scp(1), cat(1), chmod(1), man(1)`,
      "man": `MAN(1)                   User Commands                   MAN(1)

NAME
       man - an interface to the system reference manuals

SYNOPSIS
       man [COMMAND]

DESCRIPTION
       Display the manual page for COMMAND.

EXAMPLES
       man ls
              Show the manual page for the ls command.
       man scp
              Show the manual page for the scp command.
       man cp
              Show the manual page for the cp command.

SEE ALSO
       ls(1), cd(1), cat(1), pwd(1), clear(1), exit(1), file(1), chmod(1), scp(1), cp(1)`
    };

    function getPermissions(path, isDir) {
      if (isDir) {
        return "drwxr-xr-x"; // Default directory permissions
      }
      if (filePermissions[path]) {
        let { r, w, x } = filePermissions[path];
        return `${r ? "r" : "-"}w${x ? "x" : "-"}r-xr-x`; // Simplified: owner rwx, group/others r-x
      }
      return "-rwxr-xr-x"; // Default file permissions
    }

    function formatLongListing(files, dirPath) {
      let output = [];
      files.forEach(file => {
        let fullPath = dirPath === "/" ? `/${file}` : `${dirPath}/${file}`;
        let isDir = fileSystem[fullPath] !== undefined;
        let perms = getPermissions(fullPath, isDir);
        let size = fileContents[fullPath] ? fileContents[fullPath].length : 4096; // Simplified size: file content length or 4096 for dirs
        let date = "Aug 27 16:32"; // Static date for simplicity
        output.push(`${perms} ${size} ${date} ${file}`);
      });
      return output.join("\n");
    }

    function showSuccessPopup() {
      popup.innerHTML = `
        You have stopped the terrorist attack!<br>
        <button onclick="window.location.href='select.html'">Return to Home</button>
      `;
      popup.style.display = "block";
    }

    function renderPrompt() {
      return `student@oppcus:${cwd.replace("/home/student", "~")}$ `;
    }

    function renderTerminal() {
      terminal.innerHTML = "";
      history.forEach(line => terminal.innerHTML += line + "\n");
      let before = currentInput.slice(0, cursorPos);
      let atCursor = currentInput[cursorPos] || " ";
      let after = currentInput.slice(cursorPos + 1);
      terminal.innerHTML += `<span class="input-line">${renderPrompt()}${before}<span class="cursor">${atCursor}</span>${after}</span>`;
      terminal.scrollTop = terminal.scrollHeight;
    }

    function runCommand(input) {
      let args = input.trim().split(" ").filter(Boolean);
      let cmd = args[0];
      let output = "";

      if (!cmd) return "";

      switch(cmd) {
        case "ls":
          let showHidden = args.includes("-a") || args.includes("--all");
          let showLong = args.includes("-l");
          // Find the path argument (first non-option argument after ls)
          let pathArg = args.slice(1).find(arg => !arg.startsWith("-")) || null;

          let pathToList = cwd;
          if (pathArg) {
            // Remove trailing slash for directory lookup
            pathArg = pathArg.replace(/\/$/, "");
            pathToList = pathArg.startsWith("/") ? pathArg : (cwd === "/" ? "" : cwd) + "/" + pathArg;
            if (!fileSystem[pathToList]) {
              output = `ls: cannot access '${pathArg}': No such file or directory`;
              break;
            }
          }
          let files = fileSystem[pathToList] || [];
          if (showHidden) {
            files = [".", "..", ...files];
          } else {
            files = files.filter(f => !f.startsWith("."));
          }
          if (showLong) {
            output = formatLongListing(files, pathToList);
          } else {
            output = files.join("  ");
          }
          break;

        case "cd":
          let target = args[1] || "/home/student";
          // Remove trailing slash for directory lookup
          target = target.replace(/\/$/, "");
          if (target === "..") {
            if (cwd !== "/home/student") cwd = cwd.split("/").slice(0, -1).join("/") || "/";
          } else if (target === "~") cwd = "/home/student";
          else {
            let newPath = target.startsWith("/") ? target : (cwd === "/" ? "" : cwd) + "/" + target;
            if (fileSystem[newPath]) cwd = newPath;
            else output = `bash: cd: ${target}: No such file or directory`;
          }
          break;

        case "cat":
          let file = args[1];
          if (!file) output = "bash: cat: missing operand";
          else {
            let filePath = file.startsWith("/") ? file : (cwd === "/" ? "" : cwd) + "/" + file;
            if (fileContents[filePath]) {
              if (filePermissions[filePath]?.r) {
                output = fileContents[filePath];
              } else {
                output = `bash: cat: ${file}: Permission denied`;
              }
            } else {
              output = `bash: cat: ${file}: No such file or directory`;
            }
          }
          break;

        case "pwd":
          output = cwd;
          break;

        case "clear":
          history = ["Type 'exit' to return to Home"];
          currentInput = "";
          cursorPos = 0;
          return "";

        case "exit":
          window.location.href = "select.html";
          break;

        case "file":
          let targetFile = args[1];
          if (!targetFile) {
            output = "file: missing operand";
          } else if (targetFile === "." || targetFile === "..") {
            output = `${targetFile}: directory`;
          } else {
            let filePath = targetFile.startsWith("/") ? targetFile : (cwd === "/" ? "" : cwd) + "/" + targetFile;
            if (fileSystem[filePath]) {
              output = `${targetFile}: directory`;
            } else if (fileContents[filePath]) {
              output = `${targetFile}: ASCII text`;
            } else {
              output = `file: cannot access '${targetFile}': No such file or directory`;
            }
          }
          break;

        case "chmod":
          let permArg = args[1];
          let chmodFile = args[2];
          if (!permArg || !chmodFile) {
            output = "chmod: missing operand";
          } else {
            let filePath = chmodFile.startsWith("/") ? chmodFile : (cwd === "/" ? "" : cwd) + "/" + chmodFile;
            if (!fileContents[filePath] && !fileSystem[filePath]) {
              output = `chmod: cannot access '${chmodFile}': No such file or directory`;
            } else if (permArg === "+r" || permArg === "+4") {
              if (filePermissions[filePath]) {
                filePermissions[filePath].r = true;
                output = `Permissions updated for ${chmodFile}`;
              } else {
                output = `chmod: cannot modify permissions for ${chmodFile}: Not supported`;
              }
            } else {
              output = `chmod: invalid mode: '${permArg}'`;
            }
          }
          break;

        case "scp":
          let scpFile = args[1];
          if (!scpFile) {
            output = "scp: missing file operand";
          } else if (scpFile !== "ctf" && scpFile !== ".malicious-contents.txt" && scpFile !== "ctf_1010101010010101") {
            output = `scp: cannot access '${scpFile}': Only .malicious-contents.txt, ctf, or ctf_1010101010010101 is allowed`;
          } else {
            // Handle "ctf" or "ctf_1010101010010101" as aliases for ".malicious-contents.txt"
            let targetFile = (scpFile === "ctf" || scpFile === "ctf_1010101010010101") ? ".malicious-contents.txt" : scpFile;
            let filePath = targetFile.startsWith("/") ? targetFile : (cwd === "/" ? "" : cwd) + "/" + targetFile;
            if (!fileContents[filePath]) {
              output = `scp: cannot access '${scpFile}': No such file or directory`;
            } else if (!filePermissions[filePath]?.r) {
              output = `scp: cannot open '${scpFile}' for reading: Permission denied`;
            } else if (fileSystem[filePath]) {
              output = `scp: '${scpFile}' is a directory`;
            } else {
              output = `Successfully downloaded`;
              showSuccessPopup();
            }
          }
          break;

        case "cp":
          let sourceFile = args[1];
          let destPath = args[2];
          if (!sourceFile || !destPath) {
            output = "cp: missing file operand";
          } else {
            // Handle "ctf" as alias for ".malicious-contents.txt"
            let targetSource = sourceFile === "ctf" ? ".malicious-contents.txt" : sourceFile;
            let sourcePath = targetSource.startsWith("/") ? targetSource : (cwd === "/" ? "" : cwd) + "/" + targetSource;
            let destFilePath = destPath.startsWith("/") ? destPath : (cwd === "/" ? "" : cwd) + "/" + destPath;
            let destDir = destFilePath.split("/").slice(0, -1).join("/") || "/";
            if (!fileContents[sourcePath]) {
              output = `cp: cannot stat '${sourceFile}': No such file or directory`;
            } else if (!filePermissions[sourcePath]?.r) {
              output = `cp: cannot open '${sourceFile}' for reading: Permission denied`;
            } else if (!fileSystem[destDir]) {
              output = `cp: cannot create file '${destPath}': No such file or directory`;
            } else if (fileSystem[sourcePath]) {
              output = `cp: '${sourceFile}' is a directory`;
            } else {
              fileSystem[destDir].push(destFilePath.split("/").pop());
              fileContents[destFilePath] = fileContents[sourcePath];
              filePermissions[destFilePath] = { ...filePermissions[sourcePath] };
              output = `Copied ${sourceFile} to ${destPath}`;
            }
          }
          break;

        case "man":
          let command = args[1];
          if (!command) {
            output = "man: missing operand\nTry 'man man' for help";
          } else if (manPages[command]) {
            output = manPages[command];
          } else {
            output = `man: no manual entry for ${command}`;
          }
          break;

        default:
          output = `bash: ${cmd}: command not found`;
      }

      return output;
    }

    function autocomplete() {
      let args = currentInput.trim().split(" ").filter(Boolean);
      let last = args[args.length - 1];
      let matches = [];

      if (["ls", "ls -a", "ls -l", "cd", "cat", "file", "chmod", "scp", "cp"].includes(args[0])) {
        let dirPath = cwd;
        let filePart = last;
        let prefix = args[0] === "ls -a" || args[0] === "ls -l" ? args[0] : args[0] + " ";

        // Handle chmod with mode argument (e.g., chmod +r .)
        if (args[0] === "chmod" && args.length >= 2 && ["+r", "+4"].includes(args[1])) {
          prefix = args[0] + " " + args[1] + " ";
          filePart = args.length > 2 ? args[2] : "";
        }

        // Handle cp with source argument (e.g., cp .malicious-contents.txt ../)
        if (args[0] === "cp" && args.length >= 2 && !args[1].startsWith("-")) {
          prefix = args[0] + " " + args[1] + " ";
          filePart = args.length > 2 ? args[2] : "";
        }

        // Handle paths like "Desktop/" or "Desktop/RE"
        if (filePart.includes("/")) {
          let parts = filePart.split("/");
          filePart = parts.pop();
          let dir = parts.join("/");
          dirPath = dir.startsWith("/") ? dir : (cwd === "/" ? "" : cwd) + "/" + dir;
          // Remove trailing slash for directory lookup
          dirPath = dirPath.replace(/\/$/, "");
        }

        let files = fileSystem[dirPath] || [];
        // Include hidden files for commands that can handle them
        matches = files.filter(f => f.startsWith(filePart));
        if ([".", ".."].includes(filePart)) matches.push(filePart);
        // Allow "ctf" or "ctf_1010101010010101" or partial matches for scp and cp commands
        if ((args[0] === "scp" || args[0] === "cp") && ("ctf".startsWith(filePart) || "ctf_1010101010010101".startsWith(filePart))) {
          matches.push("ctf_1010101010010101");
        }

        if (matches.length === 1) {
          let completion = matches[0];
          // Append '/' for directories
          if (fileSystem[(dirPath === "/" ? "" : dirPath) + "/" + matches[0]]) {
            completion += "/";
          }
          if (filePart.includes("/")) {
            let parts = filePart.split("/");
            parts[parts.length - 1] = completion;
            currentInput = args.slice(0, -1).join(" ") + " " + parts.join("/");
          } else {
            currentInput = args.slice(0, -1).join(" ") + " " + completion;
          }
          cursorPos = currentInput.length;
        } else if (matches.length > 1 || last.endsWith("/")) {
          // Display all possible completions in history
          history.push(renderPrompt() + currentInput);
          history.push(matches.join("  "));
          currentInput = args.join(" ") + (last.endsWith("/") ? " " : "");
          cursorPos = currentInput.length;
        }
      } else {
        matches = commandsList.filter(c => c.startsWith(last));
        if (matches.length === 1) {
          currentInput = matches[0];
          cursorPos = currentInput.length;
        } else if (matches.length > 1) {
          history.push(renderPrompt() + currentInput);
          history.push(matches.join("  "));
          currentInput = args.join(" ") + " ";
          cursorPos = currentInput.length;
        }
      }
    }

    function closePopup() {
      popup.style.display = "none";
    }

    terminal.addEventListener("click", closePopup);

    document.addEventListener("keydown", (e) => {
      closePopup();
      if (e.key === "Backspace") {
        currentInput = currentInput.slice(0, cursorPos - 1) + currentInput.slice(cursorPos);
        cursorPos = Math.max(0, cursorPos - 1);
        e.preventDefault();
      } else if (e.key === "Enter") {
        let command = currentInput;
        history.push(renderPrompt() + command);
        let result = runCommand(command);
        if (result) history.push(result);
        currentInput = "";
        cursorPos = 0;
      } else if (e.key === "ArrowLeft") cursorPos = Math.max(0, cursorPos - 1);
      else if (e.key === "ArrowRight") cursorPos = Math.min(currentInput.length, cursorPos + 1);
      else if (e.key === "Tab") {
        autocomplete();
        e.preventDefault();
      } else if (e.key.length === 1) {
        currentInput = currentInput.slice(0, cursorPos) + e.key + currentInput.slice(cursorPos);
        cursorPos++;
      }
      renderTerminal();
    });

    // startup message
    history.push("Type 'exit' to return to Home");
    renderTerminal();
  </script>
</body>
</html>
